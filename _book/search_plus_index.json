{"./":{"url":"./","title":"简介","keywords":"","body":"个人介绍 这是概览页，欢迎您发现小施的学习空间 &#x1F44F; 联系方式（一起交流学习鸭～） 邮箱：951304828@qq.com github: https://github.com/shiqiongzhen 其他 gitbook 命令 // 本地服务启动 gitbook serve // 打包命令 gitbook build . docs powered by Gitbook该文件修订时间： 2021-11-08 22:52:11 new Valine({el: \"#vcomments\",appId: 'sYmTtyOH2fH7uf4VwtoFRUXd-gzGzoHsz',appKey: 'iqiqWENgagpE0W4yJrOzqRD5',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"leecode/动态规划.html":{"url":"leecode/动态规划.html","title":"动态规划","keywords":"","body":" 动态规划常见的几个步骤 确定状态 找到转移公式 确定初始条件以及边界条件 计算结果 例子1: 买股票的最佳时机 我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？ 确定状态 用一个变量记录一个历史最低价格 minprice 用一个变量记录一个历史最大盈利值 找到转移公式 当天卖出的盈利值：prices[i] - minprice，与历史时间卖出的最大盈利值作比较，得出最大值 确定初始条件以及边界条件 minprice 初始值为 Number.MAX_SAFE_INTEGER, 这样第一天股价肯定 maxProfit 初始值为 0。 计算结果 var maxProfit = function(prices) { let max = 0 let min = Number.MAX_SAFE_INTEGER for(let i=0;i max) max = prices[i]-min } return max } 例子2: 最大子序和 确定状态 定义dp[i]表示数组中前 i+1 个元素构成的连续子数组的最大和 转移公式 如果 dp[i-1] 确定初始条件以及边界条件 dp[0] = nums[0] 计算结果 var maxSubArray = function(nums) { const len = nums.length const dp = [] for(let i=0;i=1) dp[i] = Math.max(0, dp[i-1]) + nums[i] } return Math.max(...dp) }; 例子3: 打家劫舍 确定状态 定义dp[i]表示数组中 i 个元素偷的最大总金额 转移公式 dp[i] = Math.max(dp[i-2]+nums[i], dp[i])。由于两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。所以dp[i]不是dp[i-1]（没偷dp[i]），就是dp[i]+dp[i-2]（偷了dp[i]） 确定初始条件以及边界条件 自底向上推，dp[0] = inputNums[0] dp[1] = Math.max(inputNums[0], inputNums[1]) 计算结果 var rob = function(nums) { const len =nums.length let dp = [] for(let i = 0; i powered by Gitbook该文件修订时间： 2021-11-08 16:39:46 new Valine({el: \"#vcomments\",appId: 'sYmTtyOH2fH7uf4VwtoFRUXd-gzGzoHsz',appKey: 'iqiqWENgagpE0W4yJrOzqRD5',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"leecode/爬楼梯.html":{"url":"leecode/爬楼梯.html","title":"爬楼梯","keywords":"","body":"爬楼梯 题目：https://leetcode-cn.com/problems/climbing-stairs/​ 首先，什么是动态规划？ 动态规划的思路 = 递归 + 记忆 这道算法题从 3 种解法一一说明 暴力递归，由下图可见，重复计算工作随着 n 的大小指数倍上升 思路：f(n-1) + f(n-2)，记得鲁棒 动态规划：自顶向下 思路：基于1，新增 cacheArray，当cacheArray[n] 不为空的时候，进行储存，最后结果返回 cacheArray[n] 动态规划：自底向上 思路：基于 2 ，为了优化空间，将数组替换成 2 个变量 Previous 概览页 Last updated 2 hours ago WAS THIS PAGE HELPFUL? powered by Gitbook该文件修订时间： 2021-05-24 09:59:37 new Valine({el: \"#vcomments\",appId: 'sYmTtyOH2fH7uf4VwtoFRUXd-gzGzoHsz',appKey: 'iqiqWENgagpE0W4yJrOzqRD5',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"leecode/其他.html":{"url":"leecode/其他.html","title":"其他","keywords":"","body":"其他 powered by Gitbook该文件修订时间： 2021-05-10 02:59:42 new Valine({el: \"#vcomments\",appId: 'sYmTtyOH2fH7uf4VwtoFRUXd-gzGzoHsz',appKey: 'iqiqWENgagpE0W4yJrOzqRD5',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"demo/箭头函数&普通函数.html":{"url":"demo/箭头函数&普通函数.html","title":"asda","keywords":"","body":" 普通函数，this指向调用函数的对象 箭头函数，this 指向该函数所在的作用域指向的对象（即箭头函数本身没有 this，拿的是外面的 this） 如何绑定 this 为什么要 that = this 箭头函数注意事项 普通函数，this指向调用函数的对象 var name = 'window'; // 其实是window.name = 'window' var A = { name: 'A', sayHello: function(){ console.log(this.name) } } A.sayHello();// 输出A var B = { name: 'B' } A.sayHello.call(B);//输出B A.sayHello.call();//不传参数指向全局window对象，输出window.name也就是window 箭头函数，this 指向该函数所在的作用域指向的对象（即箭头函数本身没有 this，拿的是外面的 this） var name = 'window'; var A = { name: 'A', sayHello: () => { console.log(this.name) } } A.sayHello();// 还是以为输出A ? 错啦，其实输出的是window 如何绑定 this var name = 'window'; var A = { name: 'A', sayHello: function(){ var s = () => console.log(this.name) return s//返回箭头函数s } } var sayHello = A.sayHello(); sayHello();// 输出A var B = { name: 'B'; } sayHello.call(B); //还是A sayHello.call(); //还是A 为什么要 that = this this 会随着当前执行上下文而变化，that 可用于存储某执行上下文的this，如 箭头函数注意事项 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 powered by Gitbook该文件修订时间： 2021-11-08 23:13:29 new Valine({el: \"#vcomments\",appId: 'sYmTtyOH2fH7uf4VwtoFRUXd-gzGzoHsz',appKey: 'iqiqWENgagpE0W4yJrOzqRD5',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"baseFE/react-router.html":{"url":"baseFE/react-router.html","title":"React Router","keywords":"","body":" 为什么需要 React-router，为了满足更多的单页面路由场景，如嵌套路由，动态路由(/:id) Router 和 Route 的关系 Router: 完整的路由解决方案 定义：React Router 保持 UI 与 URL 同步。它拥有简单的 API 与强大的功能例如代码缓冲加载、动态路由匹配、以及建立正确的位置过渡处理。 配置方式：JSX & 对象 分类: Router 包括 HashRouter、BrowserRouter、createMemoryHistory，它主要定义了 Router 的模式 Route: 路由 Switch/Route 一般和 Link 应用：React Router 知道如何为我们搭建嵌套的 UI，因此我们不用手动找出需要渲染哪些 组件。 // JSX 配置方式 react-router-dom 和 react-router 包有什么区别 import { HashRouter, BrowserRouter, Route, Link, Switch } from 'react-router-dom'; import { Router, Route, Link } from 'react-router' react-router 基于 window.history 做了什么？ ... 参考文献 https://react-guide.github.io/react-router-cn/docs/Introduction.html powered by Gitbook该文件修订时间： 2021-06-01 17:14:40 new Valine({el: \"#vcomments\",appId: 'sYmTtyOH2fH7uf4VwtoFRUXd-gzGzoHsz',appKey: 'iqiqWENgagpE0W4yJrOzqRD5',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"baseFE/迭代器与生成器.html":{"url":"baseFE/迭代器与生成器.html","title":"迭代器与生成器","keywords":"","body":"可迭代对象(Iterable) 定义：有迭代行为的对象。为了实现可迭代，一个对象必须实现 @@iterator 方法，这意味着这个对象（或其原型链中的任意一个对象）必须具有一个带 Symbol.iterator 键（key）的属性。 内置可迭代对象：Map, set, string, array, TypedArray... // 自定义可迭代对象 var myIterable = { *[Symbol.iterator]() { yield 1; yield 2; yield 3; } } for (let value of myIterable) { console.log(value); } // 1 // 2 // 3 // 或者 [...myIterable]; // [1, 2, 3] 迭代器（@@iterator） 迭代器定义：迭代器是通过使用 next() 方法实现 Iterator protocol 的任何一个对象。在每次迭代中，next() 方法能返回一个无参函数{ done, value }> function makeRangeIterator(start = 0, end = Infinity, step = 1) { let nextIndex = start; let iterationCount = 0; const rangeIterator = { next: function() { let result; if (nextIndex 生成器(Generator函数) 生成器产生背景：使用迭代器，需要显式地维护其内部状态（done, value, next()），因此需要谨慎地创建。 生成器定义：一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。 语法：*function() => { yeild result } / asycn function() => { await result } function* makeRangeIterator(start = 0, end = Infinity, step = 1) { for (let i = start; i 异步事件的演进 可迭代协议 & 迭代器协议 参考文献 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators powered by Gitbook该文件修订时间： 2021-06-08 16:13:25 new Valine({el: \"#vcomments\",appId: 'sYmTtyOH2fH7uf4VwtoFRUXd-gzGzoHsz',appKey: 'iqiqWENgagpE0W4yJrOzqRD5',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "}}